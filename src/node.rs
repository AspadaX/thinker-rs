use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Node {
    /// A thinking step generated by LLM
    thought: String,
    /// Mark the closeness of this node to the answer
    closeness_to_answer: f32,
    /// Is this node dropped/pruned
    is_pruned: bool,
    /// Next node index
    next_node_index: Option<usize>,
    /// Previous node index
    previous_node_index: Option<usize>
}

impl Default for Node {
    fn default() -> Self {
        Self {
            closeness_to_answer: 0.0, 
            thought: "".to_string(), 
            is_pruned: false, 
            next_node_index: None, 
            previous_node_index: None 
        }
    }
}

impl Node {
    pub fn new(
        thought: String, 
    ) -> Self {
        Self {
            thought, 
            ..Default::default()
        }
    }

    pub fn assign_next_node(&mut self, next_node_index: usize) {
        self.next_node_index = Some(next_node_index);
    }

    pub fn assign_previous_node(&mut self, previous_node_index: usize) {
        self.previous_node_index = Some(previous_node_index);
    }

    pub fn get_next(&self) -> Option<usize> {
        self.next_node_index
    }

    pub fn get_previous(&self) -> Option<usize> {
        self.previous_node_index
    }

    /// Prune the branch at this node
    pub fn set_pruned(&mut self) {
        self.is_pruned = true;
    }

    /// Check the prune state
    pub fn is_pruned(&self) -> bool {
        self.is_pruned
    }
    
    pub fn access_thought(&self) -> &str {
        &self.thought
    }
    
    /// Update closeness to answer
    pub fn update_closeness(&mut self, closeness_to_answer: f32) {
        self.closeness_to_answer = closeness_to_answer;
    }
    
    pub fn get_closeness(&self) -> f32 {
        self.closeness_to_answer
    }
}