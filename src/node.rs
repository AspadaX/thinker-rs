use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct NodeCore {
    /// Mark the closeness of this node to the answer
    closeness_to_answer: f32,
    /// Thought generated by LLM
    thought: String,
    /// LLM reflections to the nodes sofar
    reflection: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Node {
    #[serde(flatten)]
    node_core: NodeCore,
    /// Is this node dropped/pruned
    is_pruned: bool,
    /// Nodes relationships
    next_node_index: Option<usize>,
    previous_node_index: Option<usize>
}

impl Default for NodeCore {
    fn default() -> Self {
        Self {
            closeness_to_answer: 0.0, 
            thought: "".to_string(), 
            reflection: None
        }
    }
}

impl Default for Node {
    fn default() -> Self {
        Self {
            node_core: NodeCore::default(), 
            is_pruned: false, 
            next_node_index: None, 
            previous_node_index: None 
        }
    }
}

impl Node {
    pub fn new(
        closeness_to_answer: f32, 
        thought: String, 
        reflection: Option<String>
    ) -> Self {
        Self {
            node_core: NodeCore {
                closeness_to_answer, 
                thought, 
                reflection
            },
            ..Default::default()
        }
    }

    pub fn assign_next_node(&mut self, next_node_index: usize) {
        self.next_node_index = Some(next_node_index);
    }

    pub fn assign_previous_node(&mut self, previous_node_index: usize) {
        self.previous_node_index = Some(previous_node_index);
    }

    pub fn get_next(&self) -> Option<usize> {
        self.next_node_index
    }

    pub fn get_previous(&self) -> Option<usize> {
        self.previous_node_index
    }

    /// Prune the branch at this node
    pub fn set_pruned(&mut self) {
        self.is_pruned = true;
    }

    /// Check the prune state
    pub fn is_pruned(&self) -> bool {
        self.is_pruned
    }
}